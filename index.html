<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0" />
<title>Chart Dashboard</title>

<!-- Lightweight Charts -->
<script src="https://unpkg.com/lightweight-charts@4.0.0/dist/lightweight-charts.standalone.production.js"></script>

<style>
:root{
  --bg:#071122; --panel:#0b2230; --muted:#94a3b8; --accent:#38bdf8;
  --up:#22c55e; --down:#ef4444; --surface:#0f1724;
  --card:#0f2a37;
}
*{box-sizing:border-box;font-family:Inter, Arial, sans-serif}
html,body{height:100%;margin:0;background:var(--bg);color:#e6eef8}
.app{display:flex;height:100vh;overflow:hidden}

/* LEFT WATCHLIST */
.side{
  width:280px;
  background:linear-gradient(180deg,#071a27 0,#071a27 100%);
  padding:18px;
  border-right:1px solid rgba(255,255,255,0.03);
  overflow:auto;
}
.side h2{margin:0 0 12px;color:var(--accent);font-size:26px}
.search{width:100%;padding:10px;border-radius:8px;border:none;background:#071826;color:#cfe6ff;margin-bottom:12px}
.watchlist{list-style:none;margin:0;padding:0}
.watchlist li{
  background:#122b36;margin:8px 0;padding:12px;border-radius:8px;cursor:pointer;
  color:#e6eef8;font-weight:600;text-transform:uppercase
}
.watchlist li.active{background:#244f63}
.add-row{display:flex;gap:8px;margin-top:12px}
.add-row input{flex:1;background:#071026;color:#cfe6ff;padding:10px;border-radius:8px;border:none}
.add-row button{background:var(--accent);border:none;color:black;padding:10px 14px;border-radius:8px;cursor:pointer}

/* RIGHT PANEL (will become top ribbon) */
.top-controls{
  width:100%;
  display:flex;
  justify-content:center;
  gap:20px;
  padding:12px;
  background:#0b1b28;
  border-bottom:1px solid rgba(255,255,255,0.05);
}
.top-controls .group{
  display:flex;
  align-items:center;
  gap:6px;
  color:#cfe6ff;
}
.top-controls input[type="number"]{
  width:60px;padding:6px;border-radius:6px;border:none;background:#071827;color:#cfe6ff;
}
.top-controls input[type="checkbox"]{transform:scale(1.1)}

/* MAIN CHART */
.main{flex:1;display:flex;flex-direction:column}
.toolbar{
  height:55px;
  background:#0b1620;
  display:flex;
  align-items:center;
  padding:0 20px;
  gap:20px;
  border-bottom:1px solid rgba(255,255,255,0.05);
}
.title{font-size:20px;font-weight:700;color:#fff}
.tf-group{display:flex;gap:10px}
.tf-btn{
  padding:8px 12px;border-radius:8px;border:none;
  background:#112030;color:#cfe6ff;cursor:pointer;
}
.tf-btn.active{background:var(--accent);color:#01222b}

/* CHART AREA */
.chart-wrap{flex:1;min-height:0;padding:0;margin:0}
#chart{width:100%;height:100%}

.spinner{
  position:absolute;top:50%;left:50%;transform:translate(-50%,-50%);
  padding:10px 20px;border-radius:10px;background:rgba(0,0,0,0.7);color:white;
}
.error{
  position:absolute;top:50%;left:50%;transform:translate(-50%,-50%);
  padding:10px 20px;border-radius:10px;background:#3b0f0f;color:#ffdede;display:none;
}
</style>
</head>
<body>

<div class="app">

  <!-- LEFT WATCHLIST -->
  <aside class="side">
    <h2>Watchlist</h2>
    <input id="searchInput" class="search" placeholder="Search symbol..." />

    <ul id="watchlist" class="watchlist"></ul>

    <div class="add-row">
      <input id="addSymbol" placeholder="Add symbol, e.g. RELIANCE.NS" />
      <button id="addBtn">Add</button>
    </div>
  </aside>

  <!-- MAIN SECTION -->
  <main class="main">

    <!-- TOP INDICATOR RIBBON -->
    <div class="top-controls">

      <div class="group">
        <b>Reliable S/R</b>
        <label>L</label>
        <input id="pivotLeft" type="number" value="15" min="1">
        <label>R</label>
        <input id="pivotRight" type="number" value="15" min="1">
        <input type="checkbox" id="toggleReliable" checked>
      </div>

      <div class="group">
        <b>LuxAlgo</b>
        <label>Len</label>
        <input id="luxLen1" type="number" value="50" min="2">
        <label>Mlt</label>
        <input id="luxMlt1" type="number" value="2" step="0.1">
        <input type="checkbox" id="toggleLux" checked>
      </div>

      <div class="group">
        <b>Island</b>
        <label>Trend</label>
        <input id="islandTrend" type="number" value="10" min="2">
        <input type="checkbox" id="toggleIsland" checked>
      </div>

      <div class="group">
        <b>Volume</b>
        <input type="checkbox" id="showVolume" checked>
      </div>

    </div>

    <!-- TOOLBAR (TIMEFRAMES + TITLE) -->
    <div class="toolbar">
      <div class="title" id="symbolTitle">Loading...</div>
      <div class="tf-group" id="timeframes">
        <button class="tf-btn" data-tf="1m">1m</button>
        <button class="tf-btn" data-tf="5m">5m</button>
        <button class="tf-btn" data-tf="15m">15m</button>
        <button class="tf-btn" data-tf="30m">30m</button>
        <button class="tf-btn" data-tf="60m">60m</button>
        <button class="tf-btn active" data-tf="1D">1D</button>
        <button class="tf-btn" data-tf="1W">1W</button>
        <button class="tf-btn" data-tf="1M">1M</button>
      </div>
    </div>

    <!-- CHART AREA -->
    <div class="chart-wrap">
      <div id="chart"></div>
      <div id="spinner" class="spinner" style="display:none">Loading...</div>
      <div id="error" class="error"></div>
    </div>

  </main>

</div>
<script>
// ----------------------------
// CONFIG
// ----------------------------
const ALPHA_KEY = "C99VSVXV4LQO45SE";
const DEFAULT_SYMBOLS = ["RELIANCE.NS","TCS.NS","HDFCBANK.NS","INFY.NS"];
const watchlistEl = document.getElementById("watchlist");
const addSymbolInput = document.getElementById("addSymbol");
const addBtn = document.getElementById("addBtn");
const searchInput = document.getElementById("searchInput");

const pivotLeft = document.getElementById("pivotLeft");
const pivotRight = document.getElementById("pivotRight");
const luxLen1 = document.getElementById("luxLen1");
const luxMlt1 = document.getElementById("luxMlt1");
const islandTrend = document.getElementById("islandTrend");
const showVolume = document.getElementById("showVolume");

const toggleReliable = document.getElementById("toggleReliable");
const toggleLux = document.getElementById("toggleLux");
const toggleIsland = document.getElementById("toggleIsland");

const symbolTitle = document.getElementById("symbolTitle");
const spinner = document.getElementById("spinner");
const errorBox = document.getElementById("error");
const tfButtons = document.querySelectorAll(".tf-btn");

let activeTF = "1D";
let lastSymbol = null;
let chart, candleSeries, volumeSeries;
let srLines = [];
let pollTimer = null;


// ----------------------------
// CHART INITIALIZATION
// ----------------------------
function createChart() {
    if (chart) return;

    chart = LightweightCharts.createChart(document.getElementById("chart"), {
        layout: { backgroundColor: "#0d192b", textColor: "#d1d4dc" },
        rightPriceScale: { borderColor: "#485c7b" },
        timeScale: { borderColor: "#485c7b", timeVisible: true, secondsVisible: false },
        grid: {
            vertLines: { color: "#253248" },
            horzLines: { color: "#253248" }
        }
    });

    candleSeries = chart.addCandlestickSeries({
        upColor: "#22c55e",
        downColor: "#ef4444",
        borderUpColor: "#22c55e",
        borderDownColor: "#ef4444",
        wickUpColor: "#22c55e",
        wickDownColor: "#ef4444"
    });

    volumeSeries = chart.addHistogramSeries({
        priceScaleId: "",
        scaleMargins: { top: 0.8, bottom: 0 },
        color: "#546e7a",
        priceFormat: { type: "volume" }
    });
}


// ----------------------------
// WATCHLIST MANAGEMENT
// ----------------------------
let watchSymbols = JSON.parse(localStorage.getItem("watchSymbols") || "null") || DEFAULT_SYMBOLS;

function renderWatchlist() {
    watchlistEl.innerHTML = "";
    watchSymbols.forEach(sym => {
        const li = document.createElement("li");
        li.textContent = sym;
        li.dataset.symbol = sym;
        li.addEventListener("click", () => loadChart(sym));
        watchlistEl.appendChild(li);
    });
}

addBtn.onclick = () => {
    const v = addSymbolInput.value.trim().toUpperCase();
    if (!v) return;

    if (!watchSymbols.includes(v)) {
        watchSymbols.unshift(v);
        localStorage.setItem("watchSymbols", JSON.stringify(watchSymbols));
        renderWatchlist();
    }
    addSymbolInput.value = "";
    loadChart(v);
};

searchInput.oninput = () => {
    const q = searchInput.value.toLowerCase();
    [...watchlistEl.children].forEach(li => {
        li.style.display = li.textContent.toLowerCase().includes(q) ? "" : "none";
    });
};

renderWatchlist();


// ----------------------------
// DATA FETCHING (Yahoo + AlphaVantage fallback)
// ----------------------------

async function fetchYahoo(symbol) {
    const url = `https://query1.finance.yahoo.com/v8/finance/chart/${symbol}?interval=1d&range=1y`;
    try {
        const r = await fetch(url);
        const j = await r.json();
        if (!j.chart || !j.chart.result) return null;

        const result = j.chart.result[0];
        const ts = result.timestamp;
        const q = result.indicators.quote[0];

        let out = [];
        for (let i = 0; i < ts.length; i++) {
            if (!q.open[i]) continue;
            out.push({
                time: ts[i],
                open: q.open[i],
                high: q.high[i],
                low: q.low[i],
                close: q.close[i],
                volume: q.volume[i]
            });
        }
        return out;
    } catch {
        return null;
    }
}

async function fetchAlpha(symbol) {
    const url = `https://www.alphavantage.co/query?function=TIME_SERIES_DAILY&symbol=${symbol}&apikey=${ALPHA_KEY}`;
    try {
        const r = await fetch(url);
        const j = await r.json();
        if (!j["Time Series (Daily)"]) return null;

        let out = [];
        Object.keys(j["Time Series (Daily)"]).forEach(date => {
            const t = Math.floor(new Date(date).getTime() / 1000);
            const o = j["Time Series (Daily)"][date];
            out.push({
                time: t,
                open: +o["1. open"],
                high: +o["2. high"],
                low: +o["3. low"],
                close: +o["4. close"],
                volume: +o["5. volume"]
            });
        });
        return out.reverse();
    } catch {
        return null;
    }
}


// UNIVERSAL FETCH
async function fetchData(symbol) {
    let d = await fetchYahoo(symbol);
    if (d && d.length) return d;

    d = await fetchAlpha(symbol);
    if (d && d.length) return d;

    return [];
}


// ----------------------------
// TIMEFRAME AGGREGATION (simple)
// ----------------------------
function aggregateTF(bars, tf) {
    if (tf === "1D") return bars;

    let sec = {
        "1m": 60,
        "5m": 300,
        "15m": 900,
        "30m": 1800,
        "60m": 3600,
        "1W": 86400 * 7,
        "1M": 86400 * 30
    }[tf];

    let groups = new Map();
    bars.forEach(b => {
        const k = Math.floor(b.time / sec);
        if (!groups.has(k)) groups.set(k, []);
        groups.get(k).push(b);
    });

    const out = [];
    [...groups.keys()].sort().forEach(k => {
        let arr = groups.get(k);
        out.push({
            time: k * sec,
            open: arr[0].open,
            high: Math.max(...arr.map(x => x.high)),
            low: Math.min(...arr.map(x => x.low)),
            close: arr[arr.length - 1].close,
            volume: arr.reduce((a, x) => a + x.volume, 0)
        });
    });

    return out;
}


// ----------------------------
// INDICATORS
// ----------------------------

// Reliable S/R
function computeReliableSR(bars, L, R) {
    let lv = [];
    for (let i = L; i < bars.length - R; i++) {
        const ph = bars[i].high > Math.max(...bars.slice(i - L, i + R + 1).map(b => b.high));
        const pl = bars[i].low < Math.min(...bars.slice(i - L, i + R + 1).map(b => b.low));
        if (ph) lv.push({ price: bars[i].high, color: "#ff4444" });
        if (pl) lv.push({ price: bars[i].low, color: "#00ff88" });
    }
    return lv;
}

// LuxAlgo simplified
function computeLuxSR(bars, len, mlt) {
    if (bars.length < len) return [];
    const closes = bars.map(b => b.close);
    let sma = [];
    for (let i = 0; i < closes.length; i++) {
        if (i < len) { sma.push(null); continue; }
        sma.push(closes.slice(i - len, i).reduce((a, x) => a + x, 0) / len);
    }
    let std = [];
    for (let i = 0; i < closes.length; i++) {
        if (i < len) { std.push(null); continue; }
        let block = closes.slice(i - len, i);
        let m = sma[i];
        std.push(Math.sqrt(block.reduce((s, x) => s + (x - m) ** 2, 0) / len));
    }
    let last = closes.length - 1;
    return [
        { price: sma[last] + mlt * std[last], color: "#ffcc00" },
        { price: sma[last], color: "#3399ff" },
        { price: sma[last] - mlt * std[last], color: "#9933ff" }
    ];
}


// Island Reversal simplified
function computeIsland(bars, len) {
    let out = [];
    for (let i = 2; i < bars.length - 2; i++) {
        const prev = bars[i - 1], cur = bars[i], next = bars[i + 1];
        if (cur.low > prev.high && next.high < cur.low) {
            out.push({ price: cur.high, color: "rgba(255,0,0,0.4)" });
            out.push({ price: cur.low, color: "rgba(255,0,0,0.4)" });
        }
        if (cur.high < prev.low && next.low > cur.high) {
            out.push({ price: cur.high, color: "rgba(0,255,0,0.4)" });
            out.push({ price: cur.low, color: "rgba(0,255,0,0.4)" });
        }
    }
    return out;
}


// ----------------------------
// DRAW INDICATORS
// ----------------------------
function clearIndicators() {
    srLines.forEach(pl => {
        try { candleSeries.removePriceLine(pl); } catch {}
    });
    srLines = [];
}

function drawLevels(levels) {
    levels.forEach(l => {
        let pl = candleSeries.createPriceLine({
            price: l.price,
            color: l.color,
            lineWidth: 1
        });
        srLines.push(pl);
    });
}


// ----------------------------
// LOAD CHART
// ----------------------------
async function loadChart(symbol) {
    lastSymbol = symbol;
    symbolTitle.textContent = symbol;
    createChart();
    spinner.style.display = "block";
    errorBox.textContent = "";

    let bars = await fetchData(symbol);
    spinner.style.display = "none";

    if (!bars.length) {
        errorBox.textContent = "No data for " + symbol;
        return;
    }

    bars.sort((a, b) => a.time - b.time);
    bars = aggregateTF(bars, activeTF);

    candleSeries.setData(bars.map(b => ({
        time: b.time,
        open: b.open,
        high: b.high,
        low: b.low,
        close: b.close
    })));

    if (showVolume.checked) {
        volumeSeries.setData(bars.map(b => ({
            time: b.time,
            value: b.volume,
            color: b.close >= b.open ? "#22c55e" : "#ef4444"
        })));
    } else {
        volumeSeries.setData([]);
    }

    clearIndicators();

    if (toggleReliable.checked) drawLevels(computeReliableSR(bars, +pivotLeft.value, +pivotRight.value));
    if (toggleLux.checked) drawLevels(computeLuxSR(bars, +luxLen1.value, +luxMlt1.value));
    if (toggleIsland.checked) drawLevels(computeIsland(bars, +islandTrend.value));
}


// ----------------------------
// TIMEFRAME BUTTONS
// ----------------------------
tfButtons.forEach(btn => {
    btn.onclick = () => {
        tfButtons.forEach(b => b.classList.remove("active"));
        btn.classList.add("active");
        activeTF = btn.dataset.tf;
        if (lastSymbol) loadChart(lastSymbol);
    };
});


// ----------------------------
// INITIAL LOAD
// ----------------------------
loadChart(watchSymbols[0]);

</script>
</body>
</html>
